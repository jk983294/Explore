/**
 * http://www.simnow.com.cn/product.action
 * http://www.sfit.com.cn/5_2_DocumentDown.htm
 * https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/u010908140/9656275
 * http://download.csdn.net/detail/u010908140/9656275
 * http://download.csdn.net/detail/u010908140/9656314
 */


# file path: /python/concurrent

import subprocess
from subprocess import Popen, PIPE

# The subprocess module allows you to spawn new processes, connect to their input/output/error pipes, and obtain their return codes
subprocess.call(["ls", "-l"])
subprocess.call("exit 1", shell=True)
subprocess.check_call(["ls", "-l"])
subprocess.check_call("exit 1", shell=True)                         # return code was non-zero it raises a CalledProcessError
subprocess.check_output(["echo", "Hello World!"])                   # return its output as a byte string. return code was non-zero it raises a CalledProcessError

# shell pipe
p1 = Popen(["/bin/ls","-l", "/tmp"], stdout=PIPE)
p2 = Popen(["grep", "tmp"], stdin=p1.stdout, stdout=PIPE)
p1.stdout.close()                                                   # Allow p1 to receive a SIGPIPE if p2 exits.
stdout, stderr = p2.communicate()                                   # communicate return (stdoutdata, stderrdata) tuple
print stdout




# file path: /python/concurrent
import threading
import time

# thread (low-level) and threading (higher-level, OOP) modules
# Python threads mostly used with Blocking operations(sockets in blocking mode) or I/O intensive applications
# Global Interpreter Lock (GIL):
# 1. Only one thread can execute low-level instruction in the VM at one time, race condition still a problem since only low-level instruction doesn't have race condition
# 2. Threads don't scale to multiple cores / CPUs

class myThread (threading.Thread):
    def __init__(self, threadID, name, counter):
        threading.Thread.__init__(self)
        self.threadID = threadID
        self.name = name
        self.counter = counter
    def run(self):
        print "Starting " + self.name
        # Get lock to synchronize threads
        threadLock.acquire()
        print_time(self.name, self.counter, 3)
        # Free lock to release next thread
        threadLock.release()

def print_time(threadName, delay, counter):
    while counter:
        time.sleep(delay)
        print "%s: %s" % (threadName, time.ctime(time.time()))
        counter -= 1

threadLock = threading.Lock()
threads = []

thread1 = myThread(1, "Thread-1", 1)
thread2 = myThread(2, "Thread-2", 2)

thread1.start()
thread2.start()

threads.append(thread1)
threads.append(thread2)


for t in threads:                                                               # Wait for all threads to complete
    t.join()
print "Exiting Main Thread"

# file path: /python/core
# StopIteration                 when the next() of an iterator point to None
# SystemExit                    sys.exit()
# StandardError                 Base class for all built-in exceptions except StopIteration and SystemExit.
# ArithmeticError               Base class for all errors that occur for numeric calculation.
# OverflowError                 calculation exceeds maximum limit for a numeric type.
# FloatingPointError            floating point calculation fails.
# ZeroDivisonError              division or modulo by zero
# AssertionError                failure of the Assert statement.
# AttributeError                failure of attribute reference or assignment.
# EOFError                      no input from either the raw_input() or input() function and the end of file is reached.
# ImportError                   import statement fails.
# KeyboardInterrupt             when the user interrupts program execution, usually by pressing Ctrl+c.
# LookupError                   Base class for all lookup errors.
# IndexError                    when an index is not found in a sequence.
# KeyError                      when the specified key is not found in the dictionary.
# NameError                     identifier is not found in the local or global namespace.
# UnboundLocalError             trying to access a local variable in a function or method but no value has been assigned to it.
# EnvironmentError              Base class for all exceptions that occur outside the Python environment.
# IOError                       IO operation fails
# SyntaxError                   an error in Python syntax.
# IndentationError              indentation is not specified properly.
# SystemError                   the interpreter finds an internal problem
# SystemExit                    interpreter is quit by using the sys.exit() function
# ValueError                    data type has the valid type of arguments, but the arguments have invalid values specified.
# RuntimeError                  a generated error does not fall into any category.
# NotImplementedError           an abstract method that needs to be implemented in an inherited class is not actually implemented.


# assert
def KelvinToFahrenheit(Temperature):
    assert (Temperature >= 0),"Colder than absolute zero!"
    return ((Temperature-273)*1.8)+32


# try catch
try:
    fh = open("testfile", "w")
    fh.write("This is my test file for exception handling!!")
except IOError as err:
    print "Error: can\'t find file or read data", err
    raise                                                                       # re-raise the exception
except (ValueError, TypeError):
    print "Handling multiple exceptions within the same except block"
else:
    print "Written content in the file successfully"
    fh.close()
finally:
   print "must execute"


# catch all exceptions
try:
    x = opem("file.txt", "r")
except:
    print "Unable to open file.txt"


# custom exceptions
class UsageError(Exception):
    pass

raise UsageError("User error, invalid input string specified")


# file path: /python/core
#!/usr/bin/python

# if condition
if var == 200:
   print "1 - Got a true expression value"
elif var == 150:
   print "2 - Got a true expression value"
else:
   print "3 - Got a false expression value"

# while loop
count = 0
while count < 5:
   print count, " is  less than 5"
   count = count + 1
else:
   print count, " is not less than 5"


# for loop
fruits = ['banana', 'apple',  'mango']
for fruit in fruits:
   print 'Current fruit :', fruit

for index in range(len(fruits)):
   print 'Current fruit :', fruits[index]

# walking through multi-dimensional lists
for x, y in [[1,2], [3,4], [5,6]]:
    print x, y

# pass statement, when a statement is required syntactically but you do not want any command or code to execute
if a > 5:
    pass
print "this line is always executed"
class EmptyClass:
    pass


# file path: /python/core
# all parameters in the Python language are passed by reference

def printinfo( name, age = 10 ):
    "This prints a passed info into this function"
    print "Name: ", name
    print "Age ", age
    return

printinfo( age=50, name="miki" )
printinfo( name="miki" )


# variable-length arguments
# vartuple holds the values of all nonkeyword variable arguments
# kwargs holds the values of all keyword variable arguments
def printinfo( arg1, *vartuple, **kwargs ):
    print "Output is: "
    print "single argument: ", arg1
    for var in vartuple:
        print var
    for key, value in kwargs.iteritems():
        print key, value
    return

printinfo( 10 )
printinfo( 70, 60, 50 )
printinfo( 70, 60, 50, a = 1, b = 2 )
my_arguments = (70, 60, 50)
printinfo(*my_arguments)                                            # positional arguments
my_arguments_dict = { "a" : 1, "b" : 2}
printinfo(*my_arguments, **my_arguments_dict)


# lambda
sum = lambda arg1, arg2: arg1 + arg2
print "Value of total : ", sum( 10, 20 )

# Functions as variables
def divide(a, b):
    return a / b
def call(func, *args, **kwargs):
    return func(*args, **kwargs)
call(divide, 6, 3)                                                  # 2

# file path: /python/core
from operator import attrgetter
from random import random

sorted([3, 2, 5 ,4, 7, 1])                                          # [1, 2, 3, 4, 5, 7]
sorted(('Zane', 'Bob', 'Janet'))                                    # ['Bob', 'Janet', 'Zane']
sorted({1:'a', 2:'b', 3:'c'})                                       # [1, 2, 3]

# reverse sort
sorted([3, 2, 5 ,4, 7, 1], reverse = True)                          # [7, 5, 4, 3, 2, 1]

# sort object
class Person(object):
    def __init__(self, name, age):
        self.name = name
        self.age = age
    def __repr__(self):
        return "<name: %s, age: %s>" % (self.name, self.age)

def byName_key(person):
    return person.name

jack = Person('Jack', 19)
adam = Person('Adam', 43)
becky = Person('Becky', 11)
people = [jack, adam, becky]

sorted(people)                                                      # [<name: Adam, age: 43>, <name: Jack, age: 19>, <name: Becky, age: 11>]
sorted(people, key = byName_key)                                    # [<name: Adam, age: 43>, <name: Becky, age: 11>, <name: Jack, age: 19>]

# using attrgetter
getName = attrgetter('name')
getName(jack)                                                       # 'Jack'
sorted(people, key = attrgetter('name'))                            # [<name: Adam, age: 43>, <name: Becky, age: 11>, <name: Jack, age: 19>]


# shuffle
def randomOrder_key(element):
    return random()
sorted(people, key = randomOrder_key)


# file path: /python/core
#!/bin/python
# coding: utf-8

# encode
x=u'\xe4\xf6\xfc'
# print x                                               # failed: UnicodeEncodeError: 'ascii' codec can't encode characters
print x.encode("utf-8")

# decode
x='\xc3\xa4\xc3\xb6\xc3\xbc'
x.decode("utf8")


# file path: /python/core
import math
import random

# Immutable : int, float, long, complex, string, bool, tuple
# Mutable : list, dictionary, set

counter = 100                                                               # An integer assignment
miles   = 1000.0                                                            # A floating point
name    = "John"                                                            # A string

a = b = c = 1
d, e, f = 1, 2, "john"
list1 = [1, 2, 3, 4, 5 ]


# data type conversion
print int('42')                                                             # Converts x to an integer. base specifies the base if x is a string.
print long('42')                                                            # Converts x to a long integer. base specifies the base if x is a string.
print float('42.3')                                                         # Converts x to a floating-point number.
print complex(1, 2)                                                         # Creates a complex number.
print str(42)                                                               # Converts object x to a string representation.
print repr((4, 2, ('spam', 'eggs')))                                        # Converts object x to an expression string.
print eval('40 + 2')                                                        # Evaluates a string and returns an object.
print tuple([1, 2, 3])                                                      # Converts s to a tuple.
print list((1, 2, 3))                                                       # Converts s to a list.
print set([1, 2, 3, 3])                                                     # Converts s to a set.
print dict([('limited', 1), ('all', 16), ('concept', 1)])                   # Creates a dictionary. d must be a sequence of (key,value) tuples.
print frozenset([1, 2, 3, 3])                                               # Converts s to a frozen set.
print chr(42)                                                               # Converts an integer to a character.
print unichr(42)                                                            # Converts an integer to a Unicode character.
print ord('a')                                                              # Converts a single character to its integer value.
print hex(32)                                                               # Converts an integer to a hexadecimal string.
print oct(32)                                                               # Converts an integer to an octal string.


# operator
print 2 ** 4                                                                # power
print 9 // 2                                                                # floor division
print (a and b)
print (a or b)
print not (a or b)
print a in list1
print a not in list1
print a is b                                                                # Identity operators compare the memory locations of two objects
print a is not b


# math
print abs(-1)                                                               # The absolute value of x: the (positive) distance between x and zero.
print math.ceil(1.1)                                                        # The ceiling of x: the smallest integer not less than x
print math.floor(1.1)                                                       # The floor of x: the largest integer not greater than x
print cmp(1, 2)                                                             # -1 if x < y, 0 if x == y, or 1 if x > y
print math.exp(1)                                                           # The exponential of x: ex
print math.fabs(-1.3)                                                       # The absolute value of x.
print math.log(2.73)                                                        # The natural logarithm of x, for x> 0
print math.log10(100)                                                       # The base-10 logarithm of x for x> 0 .
print max(1, 2, 3, 5, 6)                                                    # The largest of its arguments: the value closest to positive infinity
print min(1, 2, 3, 5, 6)                                                    # The smallest of its arguments: the value closest to negative infinity
print math.modf(4.2)                                                        # The fractional and integer parts of x in a two-item tuple. Both parts have the same sign as x. The integer part is returned as a float.
print pow(2, 4)                                                             # The value of x**y.
print round(0.4645, 2)                                                      # x rounded to n digits from the decimal point. Python rounds away from zero as a tie-breaker: round(0.5) is 1.0 and round(-0.5) is -1.0.
print math.sqrt(100)                                                        # The square root of x for x > 0

# random number
random.seed(5)                                                              # Sets the integer starting value used in generating random numbers. Call this function before calling any other random module function. Returns None.
print random.choice([1, 2, 4])                                              # A random item from a list, tuple, or string.
print random.randrange (1, 10, 2)                                           # A randomly selected element from range(start, stop, step), step is 2 means only odd number to be returned
print random.random()                                                       # A random float r, such that 0 is less than or equal to r and r is less than 1
print random.shuffle(list1)                                                 # Randomizes the items of a list in place. Returns None.
print random.uniform(1.0, 5.0)                                              # A random float r, such that x is less than or equal to r and r is less than y

# file path: /python/core/advanced
# generator is a special function which uses yield statement
# yield statement can only be used in a function/method
# generators is memory efficient, only the current loop variable will be created


def fibonacci():
    a = 0
    b = 1
    yield a
    yield b
    while True:
        a, b = b, a + b
        yield b

for i in fibonacci():
    if i>100:
        break
    print i


# more feature
def my_gen():
    i = 0
    while True:
        try:
            received = yield i
        except GeneratorExit:
            print "Closing"
            return
        print "Generator received: %r" % received
        i += 1

my = my_gen() # initialize
print "Caller received: %r" % my.next()                         # start the generator, get the next value
print "Caller received: %r" % my.send("Hello world")            # sends the value back to the generator
my.close()                                                      # raises GeneratorExit exception in the generator

# file path: /python/core/advanced
import itertools

# Iterator is an object which has next() method.
# iterator of an object is returned by its __iter__() method.
# Iterators can be converted to list by list() constructor
# Built-in iterators: list, dictionary, string, xrange(start, end, step), file()


class Fibonacci(object):
    def __init__(self):
        self.a = 0
        self.b = 1
        self.state = 0
    def __iter__ (self):
        return self
    def next(self):
        if self.state < 2:
            self.state += 1
            return self.state-1
        else:
            self.a, self.b = self.b, self.a + self.b
            return self.b

for i in Fibonacci():
    if i > 100:
        break
    print i


def display_iterator_content(o, stop_value=None):
    for i in o:
        if stop_value is not None and i > stop_value:
            break
        print i,
    print

# itertools module
display_iterator_content(itertools.chain('ABC', 'DEF'))                                     # A B C D E F
display_iterator_content(itertools.chain.from_iterable(['ABC', 'DEF']))                     # A B C D E F
display_iterator_content(itertools.count(10), 15)                                           # 10 11 12 13 14 15
display_iterator_content(itertools.count(2.5, 0.5), 5)                                      # 2.5 3.0 3.5 4.0 4.5 5.0
display_iterator_content(itertools.cycle('ABCD'), 'C')                                      # A B C D A B C D ...
display_iterator_content(itertools.repeat(10, 3))                                           # 10 10 10
list(itertools.imap(pow, xrange(10), itertools.repeat(2)))                                  # common use for repeat is to supply a stream of constant values to imap or zip, [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
display_iterator_content(itertools.compress('ABCDEF', [1,0,1,0,1,1]))                       # A C E F
display_iterator_content(itertools.dropwhile(lambda x: x<5, [1,4,6,4,1]))                   # 6 4 1
display_iterator_content(itertools.takewhile(lambda x: x<5, [1,4,6,4,1]))                   # 1 4
display_iterator_content(itertools.ifilter(lambda x: x%2, range(10)))                       # 1 3 5 7 9
display_iterator_content(itertools.ifilterfalse(lambda x: x%2, range(10)))                  # 0 2 4 6 8
display_iterator_content(itertools.imap(pow, (2,2,2), (2,3,4)))                             # 4 8 16
display_iterator_content(itertools.starmap(pow, [(2,2), (2,3), (2,4)]))                     # 4 8 16
display_iterator_content(itertools.islice('ABCDEFG', 2))                                    # A B
display_iterator_content(itertools.islice('ABCDEFG', 2, 4))                                 # C D
display_iterator_content(itertools.islice('ABCDEFG', 2, None))                              # C D E F G
display_iterator_content(itertools.islice('ABCDEFG', 0, None, 2))                           # A C E G
display_iterator_content(itertools.izip('ABCD', 'xy'))                                      # ('A', 'x') ('B', 'y')
display_iterator_content(itertools.izip_longest('ABCD', 'xy', fillvalue='-'))               # ('A', 'x') ('B', 'y') ('C', '-') ('D', '-')
display_iterator_content(itertools.product('ABCD', 'xy'))                                   # Ax Ay Bx By Cx Cy Dx Dy
display_iterator_content(itertools.product('ABCD', repeat=2))                               # AB AC AD BA BC BD CA CB CD DA DB DC
display_iterator_content(itertools.permutations('ABC', 2))                                  # ('A', 'B') ('A', 'C') ('B', 'A') ('B', 'C') ('C', 'A') ('C', 'B')
display_iterator_content(itertools.permutations(range(3))) permutations()                   # 012 021 102 120 201 210
display_iterator_content(itertools.combinations('ABC', 2))                                  # ('A', 'B') ('A', 'C') ('B', 'C')
display_iterator_content(itertools.combinations_with_replacement('ABC', 2))                 # ('A', 'A') ('A', 'B') ('A', 'C') ('B', 'B') ('B', 'C') ('C', 'C')


# test if one object is an iterator
a=[1,2]
li = a.__iter__()
li.next()                                           # 1
li.next()                                           # 2
li.next()                                           # StopIteration Exception

# file path: /python/core/advanced
import sys
import urllib2
from contextlib import closing

class Silence(object):
    def __enter__(self):                            # called when with statement is executed, "as x" will be the value what __enter__ returns
        pass
    def __exit__(self, type, value, traceback):     # Called when with block ends with or without exception, Receives the exception's type, value and traceback, If returns True, exception will be suppressed
        if type:
            sys.stdout.write(str(value)+"\n")
        return True

with Silence():
    6/0

# closing calls the close() method on the object specified when exiting
with closing(urllib2.urlopen('http://www.python.org')) as page:
    for line in page:
        print line

# file path: /python/core/advanced/decorator

# decorator is a function which receives the function received in the first parameter, and returns a new function which would replace the old one

def tracer_decorator(func):
    def tracer(*args, **kwargs):
        if TRACE:
            print "%s is called with args=%s, kwargs=%s" % (func.__name__, repr(args), repr(kwargs))
        ret_val = func(*args, **kwargs)
        if TRACE:
            print "%s is returning %s" % (func.__name__, repr(ret_val))
        return ret_val
    return tracer

# usage like annotation
@tracer_decorator
def my_func(a, b):
    return a+b


# entitlement check decorator
def need_userid(userid):
    def decorator(func):
        def check_userid(*args, **kwargs):
            if os.geteuid() == userid:
                return func(*args, **kwargs)
            else:
                raise OSError, "Invalid userid: %d" % os.geteuid()
        return check_userid
    return decorator

# decorator object
class need_userid(object):
    def __init__(self, userid):
        self.userid = userid

    def __call__(self, func):
        def check_userid(*args, **kwargs):
            if os.geteuid() == self.userid:
                return func(*args, **kwargs)
            else:
                raise OSError, "Invalid userid: %d" % os.geteuid()
        return check_userid


# decorator object usage, nesting decorators
@need_userid(5678)
@tracer_decorator
def my_func(a,b):
    return a+b

my_func(6,7)            # equals to my_func = need_userid(107686)(tracer_decorator(my_func)) | my_func(6,7)


# An essential tool for wrapping an existing functions, copies the wrapped function's name, docstrings
def tracer_decorator(func):
    @functools.wraps(func)
    def tracer(*args, **kwargs):
        print "%s is called" % func.__name__
        ret_val = func(*args, **kwargs)
        print "%s is returning" % func.__name__
        return ret_val
    return tracer

# decorator package, eliminates the need of nesting functions
@decorator
def trace(f, *args, **kw):
    print "calling %s with args %s, %s" % (f.func_name, args, kw)
    return f(*args, **kw)

# file path: /python/core/advanced/decorator
import time
import random
from retrying import retry
from timeout import timeout

# TODO need to find accepts returns timeout decorator package

@accepts(int, int)
@returns(int)
def my_add(a, b):
    return a + b

@timeout(1, 'Function slow; aborted')
def slow_function():
    time.sleep(5)

@retry(stop_max_attempt_number=3, stop_max_delay=10000, wait_random_min=1000, wait_random_max=2000)
def do_something_unreliable():
    if random.randint(0, 10) > 1:
        raise IOError("Broken sauce, everything is hosed!!!111one")
    else:
        return "Awesome sauce!"

# file path: /python/io
import glob

# finds all the pathnames matching a specified pattern according to the rules used by the Unix shell
glob.glob("/tm*/h*")

# file path: /python/io
import os

# std IO
str = raw_input("Enter your input: ")
print "Received input is : ", str

# input is python expression
str = input("Enter your input: ")                                   # [x*5 for x in range(2,10,2)]
print "Received input is : ", str                                   # [10, 20, 30, 40]



# os
os.rename( "test1.txt", "test2.txt" )
os.remove("text2.txt")
os.rmdir( "/tmp/test"  )
os.mkdir("newdir")
os.getcwd()                                                         # get the current directory
os.chdir("newdir")                                                  # change the current directory


# file open
fo = open("foo.txt", "wb")
print "Name of the file: ", fo.name
print "Closed or not : ", fo.closed
print "Opening mode : ", fo.mode
print "Softspace flag : ", fo.softspace


# file path: /python/io
# read file line by line
fo = open("foo.txt", "r+")
print file.readline()
fo.close()

# read file of all lines
with open('data.txt', 'r') as f:
    data = f.readlines()
    for line in data:
        words = line.split()
        print words

# file path: /python/io
from shutil import *
from glob import glob

# a number of high-level operations on files and collections of files

copytree('example', '/tmp/example')
rmtree('/tmp/example')
move('example.txt', 'example.out')                              # move a file or directory from one place to another
copyfile('shutil_copyfile.py', 'shutil_copyfile.py.copy')
copy('shutil_copy.py', 'folder')                                # copy to folder/shutil_copy.py
copy2('shutil_copy2.py', 'folder')                              # the access and modification times in the meta-data copied to the new file
copymode('shutil_copymode.py', 'file_to_change.txt')            # copy the permissions from one file to another
copystat('shutil_copystat.py', 'file_to_change.txt')            # copy other meta-data about the file (permissions, last access time, and last modified time)


# file path: /python/io
import StringIO

# StringIO â€” Read and write strings as files
output = StringIO.StringIO()
output.write('First line.\n')
output.write('Second line.\n')
contents = output.getvalue()                                        # 'First line.\nSecond line.\n'
output.close()


input = StringIO.StringIO('1\n53\n42')
input.readline()
input.readline()
input.readline()
output.close()


# file path: /python/io
import sys

print sys.version_info                      # sys.version_info(major=2, minor=7, micro=3, releaselevel='final', serial=0)
print sys.platform                          # linux2
print sys.path                              # ['', '/user/bin/python/2.7.3/lib/python2.7']
print sys.prefix                            # /user/bin/python/2.7.3/common
print sys.exit()                            # exiting from the script


# file path: /python/io
# write file
fo = open("foo.txt", "w")
fo.write( "Python is a great language.\n");
fo.write( "Yeah its great!!\n");
fo.close()

# write with
with open("hello.txt", "w") as f:
    f.write("Hello World")

# write with
with open("hello.txt", "w") as f:
    f.writelines(["Hello", "World"])


# file path: /python/misc
# indent is 4 spaces

# whitespace in Expressions and Statements
# spam(ham[1], {eggs: 2})

# Naming Convention
# CamelCase for classes
# underscore_separated method names, function names, variables

# use same typed variables in containers
# DO NOT: a=["a", "b", 42, [8,4,5], (1,2,3), {"id": 77}]

# Type conversion, Instead of type checking, convert it, It will raise TypeError / ValueError if it's not possible
def arithmetic_multiply(op1, op2):
    return int(op1) * int(op2)

# file path: /python/misc
import timeit

class A(object):
    def my_method(self):
        return "something"

a=A()
print a.my_method()
# how many lookup happen here:
# 1. globals()                      # {'A': <class '__main__.A'>, 'a': <__main__.A object at 0x9239a0c>, '__builtins__': <module '__builtin__' (built-in)>, '__package__': None, 'myvar': 77, '__name__': '__main__', '__doc__': None}
# 2. locals()                       # {'A': <class '__main__.A'>, 'a': <__main__.A object at 0x9239a0c>, '__builtins__': <module '__builtin__' (built-in)>, '__package__': None, 'myvar': 77, '__name__': '__main__', '__doc__': None}
# 3. obj.__dict__


# Call the method of the built-in type

# Performance analysis
timer = timeit.Timer("'x' in 'Hello world'")
timer.timeit(1000000)                               # run code "'x' in 'Hello world'" 1000000 times, measure its time cost

# measure time with setup
code="""
for c in my_string:
    if c == my_char:
        break
"""

setup="""
my_string="Hello world"
my_char="x"
"""

timer = timeit.Timer(code, setup)
print timer.timeit(1000000)


# Profiling
$ python -m cProfile my_script.py

# file path: /python/module/BuiltIn
from optparse import OptionParser
import argparse

parser = argparse.ArgumentParser(description='Process some integers.')
parser.add_argument('--a', type=int, dest="aValue", default=False, help="Specify the something...")
parser.add_argument('--b', action='store_const', const=42)
parser.add_argument('--c', action='store_true')
parser.add_argument('--d', action='append')
parser.add_argument('--e', type=int, dest="eValue", default=False)
parser.add_argument('--str', dest='types', action='append_const', const=str)
parser.add_argument('--verbose', '-v', action='count')
parser.add_argument('--version', action='version', version='%(prog)s 2.0')

results = parser.parse_args('--a 1 --b --c --d 5 --d 6 --str -vvv'.split())         # Namespace(aValue=1, b=42, c=True, d=['5', '6'], eValue=False, types=[<type 'str'>], verbose=3)
print results.aValue                                                                # 1
print results.eValue                                                                # False






parser = OptionParser()
parser.add_option("-f", "--file", dest="filename", help="write report to FILE")
parser.add_option("-q", "--quiet", action="store_false", dest="verbose", default=True,
                  help="don't print status messages to stdout")
(options, args) = parser.parse_args()
print "Filename: %s" % options.filename

# ./optparse_example.py -f x.txt
# Filename: x.txt


# file path: /python/module/BuiltIn
import json

data=json.load(open("/tmp/mydata.json"))
print data["firstName"]
data["firstName"] = u"James"
json.dumps(data)


# file path: /python/module/BuiltIn
import re

# match / search returns None if the regexp doesn't match
myregexp = re.compile(r"(\w+)\s*=\s*(.+)")
myregexp.match("temp_dir = /tmp")
myregexp.search("blabla temp_dir = /tmp")

# match email address
re.match("[a-z]+://[a-zA-Z0-9][a-zA-Z0-9\.-]+/.*", "http://www.google.com/")
re.match("[a-z]+://[a-zA-Z0-9][a-zA-Z0-9\.-]+/.*", "www.google.com")

# groups
re.match("([a-z]+)://([a-zA-Z0-9][a-zA-Z0-9\.-]+)/(.*)", "http://www.google.com/").groups()
re.match("([a-z]+)://([a-zA-Z0-9][a-zA-Z0-9\.-]+)/(.*)", "http://www.google.com/blalba/qwqq").groups()

# keyed groups
myregexp = re.compile(r"(?P<key>\w+)\s*=\s*(?P<value>.+)")
myregexp.match("temp_dir = /tmp").groupdict()                           # {'key': 'temp_dir', 'value': '/tmp'}

# replace / substitute
re.sub(",\s*", ",", "this, line ,  contains,   more, items ")           # 'this,line,contains,more,items'

# split
re.split(",\s*", "this, line ,  contains,   more, items ")              # ['this', 'line', 'contains', 'more', 'items']

# findall
re.findall("\d{4}-\d\d-\d\d", "dates: 2008-02-05 and 2009-10-12")       # ['2008-02-05', '2009-10-12']

# file path: /python/module/BuiltIn
import cPickle
import datetime

cPickle.dumps([1, 2, 3, "A", "B", "C"])

newdate = now + datetime.timedelta(days=6)
cPickle.dumps(newdate)                                      # "cdatetime\ndate\np1\n(S'\\x07\\xe1\\x01\\x0f'\ntRp2\n."

cPickle.dump(newdate, open("/tmp/mydata.txt", "w"))
cPickle.load(open("/tmp/mydata.txt"))

# file path: /python/module/BuiltIn
import time
import calendar
import datetime
from datetime import date

ticks = time.time()
print "Number of ticks since 12:00am, January 1, 1970:", ticks

localtime = time.localtime(ticks)
print "Local current time :", localtime

# format time
print time.time()                                                           # 1481865671.26
print time.asctime( localtime )                                             # Thu Dec 15 22:28:58 2016
print time.ctime()                                                          # Fri Dec 16 00:17:46 2016
print time.gmtime()                                                         # time.struct_time(tm_year=2016, tm_mon=12, tm_mday=16, tm_hour=5, tm_min=17, tm_sec=46, tm_wday=4, tm_yday=351, tm_isdst=0)
print time.localtime()                                                      # time.struct_time(tm_year=2016, tm_mon=12, tm_mday=16, tm_hour=0, tm_min=17, tm_sec=46, tm_wday=4, tm_yday=351, tm_isdst=0)
print time.mktime( (2009, 2, 17, 17, 3, 38, 1, 48, 0) )                     # 1234908218.0
print time.strftime("%b %d %Y %H:%M:%S", time.localtime())                  # Dec 16 2016 00:17:46
print time.strftime("%b %d %Y %H:%M:%S", time.gmtime())                     # Dec 16 2016 05:17:50
print time.strptime("Dec 16 2016 00:17:46", "%b %d %Y %H:%M:%S")            # time.struct_time(tm_year=2016, tm_mon=12, tm_mday=16, tm_hour=0, tm_min=17, tm_sec=46, tm_wday=4, tm_yday=351, tm_isdst=-1)

# measure process time
t0 = time.clock()
time.sleep( 2 )
t1 = time.clock()
print t1 - t0, "seconds process time"

# measure wall time
t0 = time.time()
time.sleep( 2 )
t1 = time.time()
print t1 - t0, "seconds wall time"

# datetime
now = date.today()
print now                                                                   # 2017-01-09
newdate = now + datetime.timedelta(days=6)                                  # 2017-01-15
print now.month                                                             # 1
birthday = date(1978, 12, 26)
age = now - birthday
print age.days                                                              # 13894


# file path: /python/module/BuiltIn
import unittest

# setUp method will be called before a test is called
# tearDown method will be called after a test is called
# unittest.main() will find all test cases in the script and executes them, execution order is by alphabet, ascending

# four type of assert:
# 1. TestCase.assert_(expr[, msg])
# 2. TestCase.assertEqual(first, second[, msg])
# 3. TestCase.assertNotEqual(first, second[, msg])
# 4. TestCase.assertRaises(exception, callable, ...)

# enhancement tool:
# nosetests will run test*.py scripts found in the current directory
# coverage measures which lines have been executed

class MyTestCase(unittest.TestCase):
    def setUp(self):
        self.seq = range(10)

    def test_range(self):
        for i in [0,1,2,3,4,5,6,7,8,9]:
            self.assert_(i in self.seq, "Missing number: %d" % i)
            self.assertEqual(self.seq.index(i), i)

    def test_range_reverse(self):
        self.seq.reverse()
        for i in [0,1,2,3,4,5,6,7,8,9]:
            self.assert_(i in self.seq, "Missing number: %d" % i)
            self.assertEqual(self.seq.index(i), 9-i)

if __name__ == '__main__':
    unittest.main()

# file path: /python/module/BuiltIn/web
import smtplib

# send email
server = smtplib.SMTP('localhost')
server.sendmail(from_addr='somebody1', to_addr='somebody2', msg="""To: somebody2@gmail.com
    From: somebody1@gmail.com
    Greetings from Python... :)
    """)
server.quit()

# file path: /python/module/BuiltIn/web
import urllib2

result = urllib2.urlopen("http://www.baidu.com/")
for line in result:
    print line

# file path: /python/oo
import copy

# copy class
class A:
    pass

a=A()
a.x=12
b=copy.copy(a)
b.x                                                     # 12
a.x=24
b.x                                                     # 12


# copy list
new_list = old_list[:]                                  # shallow copy
new_list = copy.deepcopy(old_list)                      # deep copy

# copy tuple
new_tuple = old_tuple[:]                                # shallow copy
new_tuple = copy.deepcopy(old_tuple)                    # deep copy


# file path: /python/oo
# case-insensitive dictionary, adding new method to a dict
class CIDict(dict):
    def __setitem__ (self, key, value):
        if type(key) == str:
            key = key.lower()
        dict.__setitem__(self, key, value)
    def __getitem__ (self, key):
        if type(key) == str:
            key = key.lower()
        return dict.__getitem__(self, key)

c = CIDict()
c["Apple"]=88
c["ORangE"]=99
c                                                                           # {'orange': 99, 'apple': 88}


# Emulating a function
class MyFunc(object):
    def __call__(self, a, b):
        return a/b

divide = MyFunc()
divide(6, 2)

# Overriding operators
class Severity(object):
    def __init__ (self, level, text):
        self.level = int(level)
        self.text = text
    def __str__ (self):
        return self.text
    def __repr__ (self):
        return "<Severity level=%d text=%s>" % (self.level, self.text)
    def __cmp__ (self, other):
        try:
            return cmp(self.level, other.level)
        except AttributeError:
            return

s1=Severity(5, "debug")
s2=Severity(6, "emerg")
s1 < s2                                                                     # True


# Properties are look like as simple attributes from the outside, but actually a method is called when the attribute's value is changed or read
# we define setter / getter functions for properties red & hex
class Color(object):
    def __init__ (self, red, green, blue):
        self.color = [red, green, blue]
    def as_hex(self):
        return "#%02X%02X%02X" % tuple(self.color)
    def get_red(self):
        return self.color[0]
    def set_red(self, value):
        self.color[0] = value
    red = property(get_red, set_red)
    hex = property(as_hex)

mycolor=Color(10, 20, 30)
mycolor.hex
mycolor.red

# file path: /python/oo
class Parent:
    parentAttr = 100
    def __init__(self):
        print "Calling parent constructor"
    def parentMethod(self):
        print 'Calling parent method'
    def setAttr(self, attr):
        Parent.parentAttr = attr
    def getAttr(self):
        print "Parent attribute :", Parent.parentAttr
    def myMethod(self):
        print 'Calling parent method'

class Child(Parent):
    def __init__(self):
        Parent.__init__(self)
        print "Calling child constructor"
    def childMethod(self):
        print 'Calling child method'
    def myMethod(self):                                     # override parent method
        print 'Calling child method'

p = Parent()
c = Child()                                                 # instance of child
c.childMethod()                                             # child calls its method
c.parentMethod()                                            # calls parent's method
c.setAttr(200)                                              # again call parent's method
c.getAttr()                                                 # again call parent's method

print issubclass(Child, Parent)
print isinstance(c, Child)


# file path: /python/oo
class Employee:
    'Common base class for all employees'                               # access via Employee.__doc__
    empCount = 0                                                        # class level variable
    def __init__(self, name, salary=0):
        self.name = name                                                # class instance variable
        self.salary = salary
        self.__secretCount = 0                                          # not visible outside the class definition
        Employee.empCount += 1
    def __del__(self):                                                  # destructor
        class_name = self.__class__.__name__
        print class_name, "destroyed"
    def display_employee(self):
        print "Name : ", self.name,  ", Salary: ", self.salary
    def count(self):
        Employee.__secretCount += 1
        print Employee.__secretCount
    @staticmethod
    def display_count():
        print "Total Employee %d" % Employee.empCount
    @classmethod
    def display_count(klass):
        print "Total Employee %d" % klass.empCount



emp1 = Employee("Zara", 2000)
emp1.display_employee()
print "Total Employee %d" % Employee.empCount
print emp1._Employee__secretCount                                       # access such attributes as object._className__attrName


# Built-In Class Attributes
print Employee.__doc__                                                  # Common base class for all employees
print Employee.__name__                                                 # Employee
print Employee.__module__                                               # __main__
print Employee.__bases__                                                # ()
print Employee.__dict__                                                 # {'__module__': '__main__', 'display_count': <function display_count at 0x8eb19cc>, 'empCount': 1, 'display_employee': <function display_employee at 0x8eb1a04>, '__doc__': 'Common base class for all employees', '__init__': <function __init__ at 0x8eb1994>}


# file path: /python/oo
# used to get the object's attributes and methods
dir(emp1)                                                               # ['_Employee__secretCount', '__del__', '__doc__', '__init__', '__module__', 'count', 'display_count', 'display_employee', 'empCount', 'name', 'salary']

# attribute of class
hasattr(emp1, 'age')                                                    # Returns true if 'age' attribute exists
getattr(emp1, 'age')                                                    # Returns value of 'age' attribute
setattr(emp1, 'age', 8)                                                 # Set attribute 'age' at 8
delattr(empl, 'age')                                                    # Delete attribute 'age'

class CommandRunner(object):
    def list_commands(self):
        ret = []
        for attrname in dir(self):
            if attrname.startswith("cmd_"):
                ret.append(attrname[4:])
        return ret
    def run_command(self, cmd):
        method = getattr(self, "cmd_"+cmd, None)
        if callable(method):
            method()
        else:
            print "No such command: %s" % cmd

class MyApp(CommandRunner):
    def cmd_install(self):
        print "Install command"
    def cmd_uninstall(self):
        print "Uninstall command"

app = MyApp()
print app.list_commands()
app.run_command("install")
app.run_command("xinstall")


# file path: /python/structure
#!/usr/bin/python

list = [ 'abcd', 786 , 2.23, 'john', 70.2 ]
tinylist = [123, 'john']

print list                                                          # Prints complete list
print list[0]                                                       # Prints first element of the list
print list[1:3]                                                     # Prints elements starting from 2nd till 3rd
print list[2:]                                                      # Prints elements starting from 3rd element
print tinylist * 2                                                  # Prints list two times
print list + tinylist                                               # Prints concatenated lists


[1, 2, 3] + [4, 5, 6]                                               # [1, 2, 3, 4, 5, 6]
['Hi!'] * 4                                                         # ['Hi!', 'Hi!', 'Hi!', 'Hi!']
3 in [1, 2, 3]                                                      # True

# built-in
len([1, 2, 3])                                                      # 3
cmp([123, 'xyz'], [456, 'abc'])                                     # -1
max([456, 700, 200])                                                # 700
min([456, 700, 200])                                                # 200
list((123, 'xyz', 'zara', 'abc'))                                   # [123, 'xyz', 'zara', 'abc']
[123, 'xyz'].append( 2009 )                                         # [123, 'xyz', 2009]
[123, 'xyz'].count( 123 )                                           # 1
[123, 'xyz'].extend( [2009, 'manni'] )                              # [123, 'xyz', 2009, 'manni']
[123, 'xyz'].index( 'xyz' )                                         # 1
[123, 'xyz'].insert( 1, 2009 )                                      # [123, 2009, 'xyz']
[123, 'xyz'].pop()                                                  # [123] and return 'xyz'
[123, 'xyz'].remove( 123 )                                          # ['xyz']
[123, 'xyz'].reverse()                                              # ['xyz', 123]
[123, 'xyz'].sort()                                                 # ['xyz', 123]

# Iteration
for x in [1, 2, 3]:
    print x
for i, val in enumerate([1, 2, 3]):
    print i, val

# file path: /python/structure
# using list as queue
queue = ['Eric', 'John', 'Michael']
queue.append('Terry')                       # Terry arrives
queue.append('Graham')                      # Graham arrives
queue.pop(0)                                # 'Eric', ['John', 'Michael', 'Terry', 'Graham']
queue.pop(0)                                # 'John', ['Michael', 'Terry', 'Graham']

# file path: /python/structure
# slicing, tuple, list, and string objects can be sliced
# [n] means the n indexed element
# [:n] means the first n elements
# [n:] means the last elements from index n (inclusive)
# [n:m] means a range from index n (inclusive) to m (exclusive) element
# [:] means a copy of the object
# m and n can be negative: counted back from the end (-1 means the last element)



a=["A", "B", "C", "D", "E", "F"]
a[-1]                                                       # 'F'
a[1:4]                                                      # ['B', 'C', 'D']
a[1:-1]                                                     # ['B', 'C', 'D', 'E']
a[:-3]                                                      # ['A', 'B', 'C']
text = "Hello Hi World"
text[:5]+text[8:]                                           # 'Hello World'


# functions
map(round, [5.5, 6.2, 7.9, 11.123])                         # [6.0, 6.0, 8.0, 11.0]
map(str, [6, 7, 8])                                         # ['6', '7', '8']
filter(None, [1, 2, 2, 3, 0, 0, 1, 2])                      # [1, 2, 2, 3, 1, 2]
filter(lambda x: x % 2 == 0, [1, 2, 2, 3, 0, 0, 1, 2])      # [2, 2, 0, 0, 2]


# comprehension
names = ["george", "kevin", "bob"]
result = [name.capitalize() for name in names]              # ['George', 'Kevin', 'Bob']
data = [1,2,3,5,6,7,44,55,66]
filtered = [x*2 for x in data if x>6]                       # [14, 88, 110, 132]
[y+44 for y in [x*2 for x in data if x>6] if y<100]         # [58, 132]


# file path: /python/structure
a=set((1,2,3,4,5))                                  # set([1, 2, 3, 4, 5])
a.add(1)                                            # set([1, 2, 3, 4, 5])
b=set((3,4,5,6,7))                                  # set([3, 4, 5, 6, 7])
1 in a                                              # True
a.intersection(b)                                   # set([3, 4, 5])
a - b                                               # set([1, 2])
list(a - b)                                         # [1, 2]
(a - b).issubset(a)                                 # True


# file path: /python/structure
# using list as stack
stack = [3, 4, 5]
stack.append(6)
stack.append(7)
stack.pop()                                                         # 7, [3, 4, 5, 6]
stack.pop()                                                         # 6, [3, 4, 5]

# file path: /python/structure
#!/usr/bin/python

# string
str1 = 'Hello World!'
print str1                                                      # Prints complete string
print str1[0]                                                   # Prints first character of the string
print str1[2:5]                                                 # Prints characters starting from 3rd to 5th
print str1[2:]                                                  # Prints string starting from 3rd character
print str1 * 2                                                  # Prints string two times
print str1 + "TEST"                                             # Prints concatenated string
print 'H' in str1

# raw string
print 'C:\\nowhere'
print r'C:\\nowhere'

# Unicode string
print u'Hello, world!'

# formatting
print "%s  %d" % ('Zara', 21)
fields = {"firstname": "John", "surname": "Smith"}
"Your are %(firstname)s %(surname)s" % fields

# built-in
print len('hello, world!')                                      # 13
print max('hello, world!')                                      # 'w'
print min('hello, world!')                                      # ' '
print 'hello, world!'.count('ll')                               # 1

print 'hello, world!'.find('ll')                                # 2
print 'hello, world!'.index('ll')                               # 2 raises an exception if no such index exists
print 'hello, world!'.rfind('o')                                # 8
print 'hello, world!'.rindex('o')                               # 8 raises an exception if no such index exists

print 'hello, world!'.center(20, '-')                           # '---hello, world!----'
print 'hello, world!'.zfill(20)                                 # '0000000hello, world!'
print 'hello, \tworld!'.expandtabs(4)                           # 'hello,  world!'
print 'hello, WORLD!'.swapcase()                                # 'HELLO, world!'
print ' hello, world! '.rjust(20, '-')                          # '----- hello, world!'
print ' hello, world! '.ljust(20, '-')                          # ' hello, world! -----'
print '88example88'.strip('8')                                  # 'example'
print '88example88'.rstrip('8')                                 # '88example'
print '88example88'.lstrip('8')                                 # 'example88'

print '-'.join(("a", "b", "c"))                                 # 'a-b-c'
print 'hello, world!'.replace("hello", "HELLO")                 # 'HELLO, world!'
print 'hello, \nworld!'.split()                                 # ['hello,', 'world!']
print 'hello, \nworld!'.split(" ")                              # ['hello,', '\nworld!']
print 'hello, \nworld!'.splitlines()                            # ['hello, ', 'world!']

print 'hello, world!'.decode(encoding='UTF-8',errors='strict')  # decodes the string using the codec registered for encoding
print 'hello, world!'.encode(encoding='UTF-8',errors='strict')  # an encoded version of the string

print 'ABC'.lower()
print 'hello, world!'.islower()
print 'abc'.upper()
print 'ABC'.isupper()

print 'hello, world!'.isalnum()                                 # False
print 'helloworld'.isalpha()                                    # True
print '42'.isdigit()                                            # True
print u'42'.isdecimal()                                         # True
print u'42.0'.isnumeric()                                       # False
print '   '.isspace()                                           # True
print 'This Is Title'.istitle()                                 # True
print 'hello, world!'.endswith('!')                             # True
print 'hello, world!'.startswith("hello")                       # True

print 'hello, world!'.capitalize()                              # 'Hello, world!'
print 'hello, world!'.title()                                   # 'Hello, World!'


# file path: /python/structure
#!/usr/bin/python

tuple = ( 'abcd', 786 , 2.23, 'john', 70.2  )
tinytuple = (123, 'john')

print tuple                                                                     # Prints complete tuple
print tuple[0]                                                                  # Prints first element of the tuple
print tuple[1:3]                                                                # Prints elements starting from 2nd till 3rd
print tuple[2:]                                                                 # Prints elements starting from 3rd element
print tinytuple * 2                                                             # Prints tuple two times
print tuple + tinytuple                                                         # Prints concatenated tuple

print len(tuple)                                                                # 5
786 in tuple                                                                    # True
print cmp((123, 'xyz'), (456, 'abc'))                                           # -1
max((456, 700, 200))                                                            # 700
min((456, 700, 200))                                                            # 200
aList = (123, 'xyz', 'zara', 'abc');
tuple((456, 700, 200))
for x in (1, 2, 3):
    print x

# file path: /python/structure/dict
from collections import Counter

c = Counter("An apple a day keeps the doctor")
c.update(" away")

print c["w"]                                                # 1
print c["a"]                                                # 5
print c.most_common(3)                                      # [(' ', 7), ('a', 5), ('e', 4)]
c.most_common()                                             # [(' ', 7), ('a', 5), ('e', 4), ('p', 3), ('d', 2), ('o', 2), ('y', 2), ('t', 2), ('A', 1), ('c', 1), ('h', 1), ('k', 1), ('l', 1), ('n', 1), ('s', 1), ('r', 1), ('w', 1)]


# other type
Counter(['a', 'b', 'c', 'a', 'b', 'b'])                     # Counter({'b': 3, 'a': 2, 'c': 1})
Counter({'a':2, 'b':3, 'c':1})                              # Counter({'b': 3, 'a': 2, 'c': 1})
Counter(a=2, b=3, c=1)                                      # Counter({'b': 3, 'a': 2, 'c': 1})


# example of word
cnt = Counter()
for word in ['red', 'blue', 'red', 'green', 'blue', 'blue']:
    cnt[word] += 1
cnt                                                         # Counter({'blue': 3, 'red': 2, 'green': 1})

# file path: /python/structure/dict
from collections import defaultdict

counter = defaultdict(int)

for letter in "An apple a day keeps the doctor away":
    counter[letter] += 1

print counter
# defaultdict(<type 'int'>, {'A': 1, ' ': 7, 'c': 1, 'e': 4, 'd': 2, 'h': 1, 'k': 1, 'l': 1, 'o': 2, 'n': 1, 'p': 3, 's': 1, 'r': 1, 'a': 5, 'w': 1, 'y': 2, 't': 2})

# file path: /python/structure/dict
#!/usr/bin/python
from itertools import izip

dict = {}
dict['one'] = 'This is one'
dict[2]     = 'This is two'
tinydict = {'name': 'john','code':6734, 'dept': 'sales'}
print dict['one']                                                           # Prints value for 'one' key
print dict[2]                                                               # Prints value for 2 key
print tinydict                                                              # Prints complete dictionary


print cmp({'Name': 'Zara', 'Age': 7}, {'Name': 'Mahnaz', 'Age': 27})        # -1
print len ({'Name': 'Zara', 'Age': 7})                                      # 2
print str ({'Name': 'Zara', 'Age': 7})                                      # '{'Age': 7, 'Name': 'Zara'}'
print type ({'Name': 'Zara', 'Age': 7})                                     # <type 'dict'>


dict.update(tinydict)
dict.setdefault('Age', None)                                                # if has key 'Age', set it to None
print dict.items()                                                          # [(2, 'This is two'), ('one', 'This is one')]
dict.has_key('No Exist')                                                    # False
dict.get('No Exist', 'Never')                                               # 'Never'
dict = dict.fromkeys(('name', 'age', 'sex'), 10)                            # {'age': 10, 'name': 10, 'sex': 10}
dict2 = dict.copy()                                                         # shallow copy
print tinydict.keys()                                                       # ['dept', 'code', 'name']
print tinydict.values()                                                     # ['sales', 6734, 'john']
del dict['one']                                                             # remove entry with key 'one'
dict.clear()                                                                # remove all entries in dict

# Convert a list to a dictionary in Python
a = ['hello','world','1','2']
i = iter(a)
b = dict(izip(i, i))                                                        # {'1': '2', 'hello': 'world'}

# iterate
prices={"Orange": 110, "Apple": 240}
for key, value in prices.iteritems():
    print key, value


# file path: /python/structure/dict
from collections import OrderedDict

mydict = OrderedDict()
mydict["first"] = 33
mydict["second"] = 87
mydict["third"] = 99
mydict["fourth"] = 1010

for key, value in mydict.iteritems():
    print key, value

key, value = mydict.popitem()               # last item ('fourth', 1010), OrderedDict([('first', 33), ('second', 87), ('third', 99)])
