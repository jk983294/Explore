/**
 * http://www.simnow.com.cn/product.action
 * http://www.sfit.com.cn/5_2_DocumentDown.htm
 * https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/u010908140/9656275
 * http://download.csdn.net/detail/u010908140/9656275
 * http://download.csdn.net/detail/u010908140/9656314
 */


package com.victor.script.file;


public class FileNode {

    public String relativePath;         // relative relativePath to root
    public String path;                 // absolute path
    public long lastModified;
    public long fileSize;

    public FileNode(String path, String relativePath, long lastModified, long fileSize) {
        this.path = path;
        this.relativePath = relativePath;
        this.lastModified = lastModified;
        this.fileSize = fileSize;
    }

    public String getRelativePath() {
        return relativePath;
    }

    public void setRelativePath(String relativePath) {
        this.relativePath = relativePath;
    }

    public long getLastModified() {
        return lastModified;
    }

    public void setLastModified(long lastModified) {
        this.lastModified = lastModified;
    }

    public long getFileSize() {
        return fileSize;
    }

    public void setFileSize(long fileSize) {
        this.fileSize = fileSize;
    }

    public String getPath() {
        return path;
    }

    public void setPath(String path) {
        this.path = path;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof FileNode)) return false;

        FileNode node = (FileNode) o;

        if (relativePath != null ? !relativePath.equals(node.relativePath) : node.relativePath != null) return false;

        return true;
    }

    @Override
    public int hashCode() {
        return relativePath != null ? relativePath.hashCode() : 0;
    }
}












package com.victor.script.file;

import org.apache.commons.collections.CollectionUtils;

import java.io.File;
import java.io.IOException;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;

public class FileTree {

    public String root;

    public boolean isRootValid = false;

    public Map<String, FileNode> relativePath2files;

    public Set<String> excludeFiles;

    public FileTree(String root) {
        this.root = root;
    }

    public void collect() throws IOException {
        relativePath2files = new TreeMap<>();
        File rootFile = new File(root);
        isRootValid = rootFile.exists() && rootFile.isDirectory();
        if(isRootValid){
            collect(rootFile);
        }
    }

    private void collect(File file) throws IOException {
        if ( file.isDirectory() ) {
            for(File f : file.listFiles()){
                if(CollectionUtils.isEmpty(excludeFiles) || !excludeFiles.contains(f.getCanonicalPath())){
                    collect(f);
                }
            }
        } else if(!file.isHidden() && file.canRead() && file.canWrite() && file.isFile()){
            if(CollectionUtils.isEmpty(excludeFiles) || !excludeFiles.contains(file.getCanonicalPath())){
                String relative = file.toURI().relativize(new File(root).toURI()).getPath();
                FileNode node = new FileNode(file.getCanonicalPath(), relative, file.lastModified(), file.length());
                relativePath2files.put(relative, node);
            }
        }
    }

    public String getRoot() {
        return root;
    }

    public void setRoot(String root) {
        this.root = root;
    }

    public boolean isRootValid() {
        return isRootValid;
    }

    public void setRootValid(boolean isRootValid) {
        this.isRootValid = isRootValid;
    }

    public Map<String, FileNode> getRelativePath2files() {
        return relativePath2files;
    }

    public void setRelativePath2files(Map<String, FileNode> relativePath2files) {
        this.relativePath2files = relativePath2files;
    }

    public Set<String> getExcludeFiles() {
        return excludeFiles;
    }

    public void setExcludeFiles(Set<String> excludeFiles) {
        this.excludeFiles = excludeFiles;
    }
}










package com.victor.script.file;


import org.apache.commons.collections.CollectionUtils;

import java.io.*;
import java.nio.channels.FileChannel;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class LocalFileSyncer {

    public static final long DEFAULT_COPY_BUFFER_SIZE = 16 * 1024 * 1024;

    public List<FileTree> fileTrees = new ArrayList<>();

    public LocalFileSyncer(List<String> paths) {
        if(CollectionUtils.isNotEmpty(paths)){
            for(String path : paths)
                fileTrees.add(new FileTree(path));
        }
    }

    public void sync() {
        for(FileTree fileTree : fileTrees){
            collect(fileTree);
        }

        for(int i = 0; i < fileTrees.size(); i++){
            for(int j = i + 1; j < fileTrees.size(); j++){
                sync(fileTrees.get(i), fileTrees.get(j));
                sync(fileTrees.get(j), fileTrees.get(i));
            }
        }
    }

    public void sync(FileTree src, FileTree dest) {
        if(src.isRootValid() && dest.isRootValid()){
            Map<String, FileNode> destNodes = dest.getRelativePath2files();
            for(FileNode srcNode : src.getRelativePath2files().values()){
                if(!destNodes.containsKey(srcNode.relativePath)
                        || srcNode.lastModified > destNodes.get(srcNode.relativePath).lastModified){
                    copyFile(new File(srcNode.getPath()), new File(dest.getRoot() + srcNode.relativePath));
                }
            }
        }
    }

    public void collect(FileTree tree){
        try {
            tree.collect();
        } catch (IOException e) {
            System.out.println("error when collect for " + tree.getRoot());
        }
    }

    private void copyFile(File srcFile, File destFile) {
        try (FileInputStream is = new FileInputStream( srcFile );
             FileOutputStream os = new FileOutputStream( destFile, false )) {
            FileChannel iChannel = is.getChannel();
            FileChannel oChannel = os.getChannel();
            long doneBytes = 0L;
            long todoBytes = srcFile.length();
            while ( todoBytes != 0L ) {
                long iterationBytes = Math.min( todoBytes, DEFAULT_COPY_BUFFER_SIZE );
                long transferredLength = oChannel.transferFrom( iChannel, doneBytes, iterationBytes );
                if ( iterationBytes != transferredLength ) {
                    throw new IOException("Error during file transfer: expected " + iterationBytes
                            + " bytes, only " + transferredLength + " bytes copied.");
                }
                doneBytes += transferredLength;
                todoBytes -= transferredLength;
            }
        } catch (IOException e) {
            System.out.println("Could not copy file from {} -> {} " + destFile);
        }
        boolean successTimestampOp = destFile.setLastModified( srcFile.lastModified() );
        if ( !successTimestampOp ) {
            System.out.println("Could not change timestamp for {}. Index synchronization may be slow. " + destFile );
        }
    }


}










package com.victor.script.file;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.nio.channels.FileChannel;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;


/**
 * Utility class for synchronizing files/directories.
 */
public abstract class FileHelper {

    private static final int FAT_PRECISION = 2000;
    public static final long DEFAULT_COPY_BUFFER_SIZE = 16 * 1024 * 1024;


    public static boolean areInSync(File source, File destination) throws IOException {
        if ( source.isDirectory() ) {
            if ( !destination.exists() ) {
                return false;
            }
            else if ( !destination.isDirectory() ) {
                throw new IOException(
                        "Source and Destination not of the same type:"
                                + source.getCanonicalPath() + " , " + destination.getCanonicalPath()
                );
            }
            String[] sources = source.list();
            Set<String> srcNames = new HashSet<String>( Arrays.asList( sources ) );
            String[] dests = destination.list();

            // check for files in destination and not in source
            for ( String fileName : dests ) {
                if ( !srcNames.contains( fileName ) ) {
                    return false;
                }
            }

            boolean inSync = true;
            for ( String fileName : sources ) {
                File srcFile = new File( source, fileName );
                File destFile = new File( destination, fileName );
                if ( !areInSync( srcFile, destFile ) ) {
                    inSync = false;
                    break;
                }
            }
            return inSync;
        }
        else {
            if ( destination.exists() && destination.isFile() ) {
                long sts = source.lastModified() / FAT_PRECISION;
                long dts = destination.lastModified() / FAT_PRECISION;
                return sts == dts;
            }
            else {
                return false;
            }
        }
    }

    public static void synchronize(File source, File destination, boolean smart) throws IOException {
        synchronize( source, destination, smart, DEFAULT_COPY_BUFFER_SIZE );
    }

    public static void synchronize(File source, File destination, boolean smart, long chunkSize) throws IOException {
        if ( chunkSize <= 0 ) {
            System.out.println("Chunk size must be positive: using default value." );
            chunkSize = DEFAULT_COPY_BUFFER_SIZE;
        }
        if ( source.isDirectory() ) {
            if ( !destination.exists() ) {
                if ( !destination.mkdirs() ) {
                    throw new IOException( "Could not create relativePath " + destination );
                }
            }
            else if ( !destination.isDirectory() ) {
                throw new IOException(
                        "Source and Destination not of the same type:"
                                + source.getCanonicalPath() + " , " + destination.getCanonicalPath()
                );
            }
            String[] sources = source.list();
            Set<String> srcNames = new HashSet<String>( Arrays.asList( sources ) );
            String[] dests = destination.list();

            //delete files not present in source
            for ( String fileName : dests ) {
                if ( !srcNames.contains( fileName ) ) {
                    delete( new File( destination, fileName ) );
                }
            }
            //copy each file from source
            for ( String fileName : sources ) {
                File srcFile = new File( source, fileName );
                File destFile = new File( destination, fileName );
                synchronize( srcFile, destFile, smart, chunkSize );
            }
        }
        else {
            if ( destination.exists() && destination.isDirectory() ) {
                delete( destination );
            }
            if ( destination.exists() ) {
                long sts = source.lastModified() / FAT_PRECISION;
                long dts = destination.lastModified() / FAT_PRECISION;
                //do not copy if smart and same timestamp and same length
                if ( !smart || sts == 0 || sts != dts || source.length() != destination.length() ) {
                    copyFile( source, destination, chunkSize );
                }
            }
            else {
                copyFile( source, destination, chunkSize );
            }
        }
    }

    private static void copyFile(File srcFile, File destFile, long chunkSize) throws IOException {
        FileInputStream is = null;
        FileOutputStream os = null;
        try {
            is = new FileInputStream( srcFile );
            FileChannel iChannel = is.getChannel();
            os = new FileOutputStream( destFile, false );
            FileChannel oChannel = os.getChannel();
            long doneBytes = 0L;
            long todoBytes = srcFile.length();
            while ( todoBytes != 0L ) {
                long iterationBytes = Math.min( todoBytes, chunkSize );
                long transferredLength = oChannel.transferFrom( iChannel, doneBytes, iterationBytes );
                if ( iterationBytes != transferredLength ) {
                    throw new IOException(
                            "Error during file transfer: expected "
                                    + iterationBytes + " bytes, only " + transferredLength + " bytes copied."
                    );
                }
                doneBytes += transferredLength;
                todoBytes -= transferredLength;
            }
        }
        finally {
            if ( is != null ) {
                is.close();
            }
            if ( os != null ) {
                os.close();
            }
        }
        boolean successTimestampOp = destFile.setLastModified( srcFile.lastModified() );
        if ( !successTimestampOp ) {
            System.out.println("Could not change timestamp for {}. Index synchronization may be slow. " + destFile );
        }
    }

    public static void delete(File file) {
        if ( file.isDirectory() ) {
            for ( File subFile : file.listFiles() ) {
                delete( subFile );
            }
        }
        if ( file.exists() ) {
            if ( !file.delete() ) {
                System.out.println( "Could not delete {}" + file );
            }
        }
    }
}
