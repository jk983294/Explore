/**
 * http://www.simnow.com.cn/product.action
 * http://www.sfit.com.cn/5_2_DocumentDown.htm
 * https://link.zhihu.com/?target=http%3A//download.csdn.net/detail/u010908140/9656275
 * http://download.csdn.net/detail/u010908140/9656275
 * http://download.csdn.net/detail/u010908140/9656314
 */

# file path: /python/module/numpy/basic.py
from numpy import *

# main object is the homogeneous multidimensional array
# element (usually number) is indexed by a tuple of positive integers
# the number of axes is rank

a = arange(15).reshape(3, 5)                                        # [[ 0,  1,  2,  3,  4], [ 5,  6,  7,  8,  9], [10, 11, 12, 13, 14]]
a.shape                                                             # (3, 5)
a.ndim                                                              # 2
a.dtype.name                                                        # int32
a.itemsize                                                          # 4, the size in bytes of each element of the array, sizeof(int32)
a.size                                                              # 15
type(a)                                                             # numpy.ndarray

# print array
print a
print arange(10000).reshape(100,100)                                # automatically skips the central part of the array if too large

# file path: /python/module/numpy/builtin.py
from numpy import *
from numpy.random import *
from numpy.linalg import inv

# Arithmetic operators on arrays apply element-wise. A new array is created and filled with the result.
a = array( [20,30,40,50] )                          # [20, 30, 40, 50]
b = arange( 4 )                                     # [0, 1, 2, 3]
c = a-b                                             # [20, 29, 38, 47]
b**2                                                # [0, 1, 4, 9]


# matrix operation
A = array( [[1,1], [0,1]] )
B = array( [[2,0], [3,4]] )
A*B                                                 # element-wise product, [[2, 0], [0, 4]]
dot(A,B)                                            # matrix product, [[5, 4], [3, 4]]
inv(A)                                              # inverse matrix, [[ 1., -1.], [ 0.,  1.]]
B.transpose()                                       # [[2, 3], [0, 4]]
B.diagonal()                                        # [2, 4]
B.trace()                                           # 6, sigma (B.diagonal())

# in-place operator, modify an existing array rather than create a new one
a = ones((1,2), dtype=int)                          # [[1, 1]]
b = random((1,2))                                   # [[ 0.4238594 ,  0.57967898]]
a *= 3                                              # [[3, 3]]
b += a                                              # [[ 3.4238594 ,  3.57967898]]

# by default, these operations apply to the array as though it were a list of numbers, regardless of its shape
# by specifying the axis parameter you can apply an operation along the specified axis
a = array( [[1,2], [3,4]] )
b = arange(3)                                       # [ 0, 1, 2 ]
c = array([2., -1., 4.])
d = array([[1,2,3],[4,5,6],[7,8,9]])
w = array([0.1, 0.2, 0.5])
T = array([1.3, 4.5, 2.8, 3.9])
P = array([2.7, 8.7, 4.7, 8.2])
rho = array([8.5, 5.2, 6.9, 6.5])
booleans = array([True, False, True])
a.sum()                                             # 10
a.min()                                             # 1
a.max()                                             # 4
a.mean()                                            # 2.5
a.std()                                             # 1.1180339887498949, normalized by N (not N-1)
a.var()                                             # 1.25, normalised with N (not N-1)
a.prod()                                            # 24
a.sum(axis=0)                                       # [4, 6]
a.min(axis=0)                                       # [1, 2]
a.max(axis=0)                                       # [3, 4]
a.mean(axis=0)                                      # [ 2.,  3.]
a.std(axis=0)                                       # [ 1.,  1.]
a.var(axis=0)                                       # [ 1.,  1.]
a.prod(axis=0)                                      # [3, 8]

# universal functions, these functions operate element-wise on an array, producing an array as output
exp(b)                                              # [ 1.        ,  2.71828183,  7.3890561 ]
sqrt(b)                                             # [ 0.        ,  1.        ,  1.41421356]
add(b, c)                                           # [ 2.,  0.,  6.]
inner(b, c)                                         # 7.0, sigma ( b[i] * c[i] )
outer(b, c)                                         # [[ 0., -0.,  0.], [ 2., -1.,  4.], [ 4., -2.,  8.]]
cumprod(c)                                          # cumulative product, [ 2., -2., -8.]
cumsum(c)                                           # cumulative sum, [ 2.,  1.,  5.]
diff(c)                                             # 1st-order differences, [-3.,  5.]
diff(c,n=2)                                         # 2st-order differences, diff(diff(c)), [ 8.]
cross(b,c)                                          # vector cross-product, [ 6.,  4., -2.]
apply_along_axis(lambda x: (x[0]+x[-1])/2,0,d)      # apply to each column (axis=0) of d, [4, 5, 6]
apply_along_axis(lambda x: (x[0]+x[-1])/2,1,d)      # apply to each row (axis=1) of d, [2, 5, 8]

maximum(b,c)                                        # element-by-element comparison, [ 2.,  1.,  4.]
minimum(b,c)                                        # element-by-element comparison, [ 0., -1.,  2.]
median(array([1,2,3,4,9]))                          # 3.0
median(array([1,2,3,4,9,0]))                        # 2.5
average(c)                                          # 1.6666666666666667
average(c,weights=w)                                # weighted average, 2.5
bincount(b)                                         # [1, 1, 1], 0 occur 1 times, 1 occur 1 times, 2 occur 1 times
bincount(b, weights=w)                              # weighted occurrence, [ 0.1,  0.2,  0.5]
ceil(w)                                             # nearest integers >= w, [ 1.,  1.,  1.]
floor(w)                                            # nearest integers <= w, [ 0.,  0.,  0.]
w.round()                                           # [ 0.,  0.,  0.]
round_(w)
around(w)
w.round(decimals=1)                                 # [ 0.1,  0.2,  0.5]
c.clip(min=1.0,max=3.0)                             # [ 2.,  1.,  3.]
clip(c,1.0,3.0)                                     # [ 2.,  1.,  3.]

corrcoef([T,P])                                     # correlation matrix [[ 1. ,  0.98062258], [ 0.98062258,  1. ]]
cov(T)                                              # 1.9758333333333333, variance, normalized by N-1
cov(T, bias=1)                                      # 1.481875, variance, normalized by N
cov(T,P)                                            # covariance, [[ 1.97583333,  3.95416667], [ 3.95416667,  8.22916667]]

booleans.all()                                      # False
all(booleans)                                       # False
all(b > 0)                                          # False
alltrue(booleans)                                   # False
sometrue(booleans)                                  # True
alltrue(b > 0)                                      # False
booleans.any()                                      # True
any(booleans)                                       # True
(b >= 1).any()                                      # True

# index based operation
indices = b.nonzero()                               # find the indices of the nonzero elements, [1, 2]
b[indices]                                          # get those nonzero elements, [1, 2]




# file path: /python/module/numpy/copy.py
from numpy import *

# simple assignments make no copy of array objects or of their data.
a = arange(12)
b = a                                           # no new object is created
b is a                                          # a and b are two names for the same ndarray object

# view or Shallow Copy
# view method creates a new array object that looks at the same data.
# slicing an array returns a view of it
c = a.view()
c is a                                          # False
c.base is a                                     # True, c is a view of the data owned by a
c.flags.owndata                                 # False
c.shape = 2,6                                   # a's shape doesn't change
c[0,4] = 1234                                   # a's data changes

# Deep Copy
d = a.copy()                                    # a new array object with new data is created
d is a                                          # False
d.base is a                                     # False, d doesn't share anything with a
d[0] = 9999                                     # a's data won't change

# file path: /python/module/numpy/creation.py
from numpy import *
from numpy.random import *

# merge
vstack([[1, 2],[3, 4],[5, 6]])                                      # [[1, 2], [3, 4], [5, 6]]
hstack([[1, 2],[3, 4],[5, 6]])                                      # [1, 2, 3, 4, 5, 6]
concatenate(([[1,2],[3,4]],[[5,6],[7,8]]))                          # [[1, 2], [3, 4], [5, 6], [7, 8]]
concatenate(([[1,2],[3,4]],[[5,6],[7,8]]),axis=1)                   # [[1, 2, 5, 6], [3, 4, 7, 8]]
# column_stack stacks 1D arrays as columns into a 2D array. It is equivalent to vstack only for 1D arrays
column_stack([[1, 2],[3, 4],[5, 6]])                                # [[1, 3, 5], [2, 4, 6]]
row_stack([[1, 2],[3, 4],[5, 6]])                                   # [[1, 2], [3, 4], [5, 6]]
# r_[] and c_[] are useful for creating arrays by stacking numbers along one axis. they allow the use of range literals (":")
r_[1:5]                                                             # same as arange(1,5), [1, 2, 3, 4]
r_[1:10:4]                                                          # same as arange(1,10,4), [1, 5, 9]
r_[1:10:4j]                                                         # same as linspace(1,10,4), [ 1., 4., 7., 10.]
r_[1:5,7,1:10:4]                                                    # [1, 2, 3, 4, 7, 1, 5, 9]
r_['r', 1:3]                                                        # return a matrix. [[1, 2]]
r_['c',1:3]                                                         # return a matrix. [[1], [2]]
r_[[[1,2],[4,5]],[[1,2],[4,5]]]                                     # concatenation along row, [1, 2], [4, 5], [1, 2], [4, 5]]
r_['-1',[[1,2],[4,5]],[[1,2],[4,5]]]                                # concatenation along column, [[1, 2, 1, 2], [4, 5, 4, 5]]
c_[1:5]                                                             # [1, 2, 3, 4]
c_[1:5,2:6]                                                         # [[1, 2], [2, 3], [3, 4], [4, 5]]

# split
a = array([[3, 4, 5], [6, 7, 8]])
hsplit(a,3)                                                         # [[3], [6]], [[4], [7]], [[5], [8]]
hsplit(a,[1,2])                                                     # split along with column 1 and 2, [[3], [6]], [[4], [7]], [[5], [8]]
b = array([[3, 4], [5, 6], [7, 8]])
vsplit(b,3)                                                         # [[3, 4]], [[5, 6]], [[7, 8]]
vsplit(b,[1,2])                                                     # split along with row 1 and 2, [[3, 4]], [[5, 6]], [[7, 8]]
array_split(a,2,axis=0)                                             # split a in 2 parts. row-wise
array_split(a,3,axis=1)                                             # split a in 4 parts, column-wise
array_split(a,[1,2],axis=1)                                         # make a split before the 1st and the 2nd column

# Array Creation
b = array([1.2, 3.5, 5.1])
b = array([[3, 4, 5], [6, 7, 8]])
b = array( [ (1.5,2,3), (4,5,6) ] )
c = array( [ [1,2], [3,4] ], dtype=complex )                        # [[ 1.+0.j,  2.+0.j], [ 3.+0.j,  4.+0.j]]

zeros( (1,2) )                                                      # zeros creates an array full of zeros
zeros_like(b)                                                       # with zeros initialised array with the same shape and datatype as b
ones( (1,2,3), dtype=int16 )                                        # ones creates an array full of ones
ones_like(b)                                                        # ones initialised array with the same shape and datatype as b
empty( (1,2) )                                                      # empty creates an array whose initial content is random
empty_like(b)                                                       # uninitialized array with the same shape and datatype as b
eye(1,2,0,dtype=float)                                              # [[ 1.,  0.]]
eye(1,2,1,dtype=float)                                              # [[ 0.,  1.]]
identity(2,float)                                                   # [[ 1.,  0.], [ 0.,  1.]]

arange(6)                                                           # [0, 1, 2, 3, 4, 5]
arange(6).reshape(1,2,3)                                            # [[[0, 1, 2], [3, 4, 5]]]
arange( 10, 30, 5 )                                                 # start, end, step, [10, 15, 20, 25]
arange( 0, 2, 0.3 )                                                 # [ 0. ,  0.3,  0.6,  0.9,  1.2,  1.5,  1.8]

linspace( 0, 2, 5 )                                                 # start, end, count, [ 0. ,  0.5,  1. ,  1.5,  2. ]
x = linspace( 0, 2*pi, 100 )                                        # useful to evaluate function at lots of points
f = sin(x)

fromfunction(lambda i, j: i**2 + j**2, (2,2))                       # evaluate functiom, [[ 0.,  1.], [ 1.,  2.]]

y = array([2.,4.,6.,8.])
y.tofile("myfile.dat")                                              # binary format
fromfile('myfile.dat', dtype=float)                                 # array([ 2., 4., 6., 8.])

y.tofile("myfile.txt", sep='\n', format = "%e")                     # ascii format, one column, exponential notation
fromfile('myfile.txt', dtype=float, sep='\n')

rand(2,1)                                                           # uniform distribution, [[ 0.83604898], [ 0.79689486]]
randn(2,1)                                                          # standard normal distribution, [[ 0.29441506], [-0.49656679]]
random_integers(-5,5,(2,2))                                         # [[ 2, -5], [ 2,  4]]
random_sample((2, 2))                                               # range [0.0, 1.0)


# file path: /python/module/numpy/function.py
from numpy import *

def my_func(x):
    if x >= 0: return x**2
    else: return -x

my_func(2.)                                         # 4.0
vec_func = vectorize(my_func, otypes=[float])       # declare the return type as float
vec_func(array([-2,2]))                             # [ 2.,  4.]

# file path: /python/module/numpy/iteration.py
from numpy import *

a = arange(10)**3                   # [  0,   1,   8,  27,  64, 125, 216, 343, 512, 729]
b = fromfunction(lambda x, y : 10 * x + y,(5,4),dtype=int)

# iterating 1-d array
for i in a:
    print i**(1/3.),

# xrange is faster than range, xrange is a sequence object that evaluates lazily
for i in xrange(0, 20):
    print i,

for i in range(0, 20):
    print i,

# iterating over multidimensional arrays
for row in b:
    print row

# iterating over multidimensional arrays and perform an operation on each element
for element in b.flat:
    print element,

# index & slice
a[2]                                # 8
a[[1, 2, 3]]                        # [ 1,  8, 27]
idx = array( [ [1, 2], [2, 3] ] )   # a bidimensional array of indices
a[idx]                              # the same shape as idx, [[ 1,  8], [ 8, 27]]
a[2:5]                              # [ 8, 27, 64]
a[:6:2] = -1000                     # [-1000,     1, -1000,    27, -1000,   125,   216,   343,   512,   729], equivalent to a[0:6:2] = -1000; from start to position 6, exclusive, set every 2nd element to -1000
b[2,3]
b[0:5, 1]                           # second column of b
b[ : ,1]                            # second column of b
b[1:3, : ]                          # second and third row of b
b[-1]                               # the last row. Equivalent to b[-1,:]
i = array( [ [0,1],  [1,2] ] )      # indices for the first dim of a
j = array( [ [2,1], [3,3] ] )       # indices for the second dim of a
b[i,j]

# ... represent as many colons as needed to produce a complete indexing tuple
# if x is a rank 5 array (i.e., it has 5 axes), then
# x[1,2,...] = x[1,2,:,:,:]
# x[...,3] = x[:,:,:,:,3]
# x[4,...,5,:] = x[4,:,:,5,:]


# reverse
a[ : :-1]                           # [  729,   512,   343,   216,   125, -1000,    27, -1000,     1, -1000]



# file path: /python/module/numpy/LinearAlgebra.py
from numpy import *
from numpy.linalg import *

a = array([[1.0, 2.0], [3.0, 4.0]])
j = array([[0.0, -1.0], [1.0, 0.0]])
y = array([[5.], [7.]])
a.transpose()                               # [[ 1.,  3.],  [ 2.,  4.]]
inv(a)                                      # [[-2. ,  1. ], [ 1.5, -0.5]]
u = eye(2)                                  # unit 2x2 matrix; [[ 1.,  0.], [ 0.,  1.]]
dot (j, j)                                  # matrix product, [[-1.,  0.], [ 0., -1.]]
trace(u)                                    # trace, 2.0
solve(a, y)                                 # [[-3.], [ 4.]]
eig(j)                                      # eigenvalues

# matrix class
M = mat(arange(12).reshape([3, 4]).copy())
M[:,1]                                      # [[1], [5], [9]])
A = matrix('1.0 2.0; 3.0 4.0')              # [[ 1.  2.] [ 3.  4.]]
type(A)                                     # file where class is defined, 'numpy.matrixlib.defmatrix.matrix'
A.T                                         # transpose, [[ 1.  3.] [ 2.  4.]]
X = matrix('5.0 7.0')
Y = X.T                                     # [[5.] [7.]]
print A*Y                                   # matrix multiplication, [[19.] [43.]]
print A.I                                   # inverse, [[-2.   1. ] [ 1.5 -0.5]]
solve(A, Y)                                 # solving linear equation, matrix([[-3.], [ 4.]])

# file path: /python/module/numpy/plot.py

import numpy
import pylab
# Build a vector of 10000 normal deviates with variance 0.5^2 and mean 2
mu, sigma = 2, 0.5
v = numpy.random.normal(mu,sigma,10000)
# Plot a normalized histogram with 50 bins
pylab.hist(v, bins=50, normed=1)       # matplotlib version (plot)
pylab.show()
# Compute the histogram with numpy and then plot it
(n, bins) = numpy.histogram(v, bins=50, normed=True)  # NumPy version (no plot)
pylab.plot(.5*(bins[1:]+bins[:-1]), n)
pylab.show()

# file path: /python/module/numpy/shape.py

from numpy import *
from numpy.random import *

a = floor(10*random((3,4)))             # [[ 2.,  8.,  4.,  2.], [ 6.,  5.,  6.,  3.], [ 1.,  8.,  6.,  6.]]
a.shape                                 # (3, 4)
a.ravel()                               # flatten the array
a.shape = (6, 2)                        # [[ 2.,  8.], [ 4.,  2.], [ 6.,  5.], [ 6.,  3.], [ 1.,  8.], [ 6.,  6.]]

# reshape return a new matrix, while resize change itself
a.resize((2,6))                         # [[ 7.,  5.,  9.,  3.,  7.,  2.], [ 7.,  8.,  6.,  8.,  3.,  2.]]
# if a dimension is given as -1 in a reshaping operation, the other dimensions are automatically calculated
a.reshape(3,-1)                         # [[ 7.,  5.,  9.,  3.], [ 7.,  2.,  7.,  8.], [ 6.,  8.,  3.,  2.]]
# -1 means "whatever is needed"
a.shape = 2,-1,3                        # [[[ 7.,  3.,  5.], [ 9.,  5.,  3.]], [[ 9.,  7.,  6.], [ 3.,  5.,  5.]]]

# file path: /python/module/numpy/sort_and_search.py
from numpy import *

# 1-d array sort
a = array([2,0,8,4,1])
ind = a.argsort(kind='merge')                   # options are 'quicksort', 'mergesort' and 'heapsort'
ind = a.argsort()                               # indices of sorted array using quicksort, [1, 4, 0, 3, 2]
ind = argsort(a)                                # there is a functional form
a[ind]                                          # sort result: [0, 1, 2, 4, 8]

# multi-dimension array sort
a = array([[8,4,1],[2,0,9]])
ind = a.argsort(axis=0)                         # sorts on columns. [[1, 1, 0], [0, 0, 1]]
a[ind,[[0,1,2],[0,1,2]]]                        # sort result: [[2, 0, 1], [8, 4, 9]]
ind = a.argsort(axis=1)                         # sort along rows. [[2, 1, 0], [1, 0, 2]]

# lexsort, sort by height, then width
serialnr = array([1023, 5202, 6230, 1671, 1682, 5241])
height = array([40., 42., 60., 60., 98., 40.])
width = array([50., 20., 70., 60., 15., 30.])
indices = lexsort(keys = (width, height))       # [5, 0, 1, 3, 2, 4]
for n in indices:
    print serialnr[n], height[n], width[n]

# alternatively: all data in one big matrix, sort on last row, then on 2nd last row, etc.
a = vstack([serialnr,width,height])
indices = lexsort(a)
a.take(indices, axis=-1)

# find max min
b = arange(3)                                       # [ 0, 1, 2 ]
d = array([[1,2,3],[4,5,6],[7,8,9]])
b.argmax()                                          # 1
idx = d.argmax(axis=0)                              # for each column: the row index of the maximum value, [2, 2, 2]
d[idx, xrange(d.shape[1])]                          # get max value of each column
idx = d.argmax(axis=1)                              # for each row: the row index of the maximum value, [2, 2, 2]
d[xrange(d.shape[0]), idx]                          # get max value of each row
b.argmin()                                          # 0
idx = d.argmin(axis=0)                              # for each column: the row index of the minimum value, [0, 0, 0]
d[idx, xrange(d.shape[1])]                          # get min value of each column
idx = d.argmin(axis=1)                              # for each row: the row index of the minimum value, [0, 0, 0]
d[xrange(d.shape[0]), idx]                          # get min value of each row

# where
a = array([3,5,7,9])
b = array([10,20,30,40])
c = array([2,4,6,8])
d = array([[3,5,7,9],[2,4,6,8]])
where(a <= 6, b, c)                             # [10, 20,  6,  8]
where(a <= 6, b, -1)                            # [10, 20, -1, -1]
indices = where(a <= 6)                         # [0, 1]
b[indices]                                      # [10, 20]
b[a <= 6]                                       # [10, 20], an alternative syntax
where(d <= 6)                                   # [0, 0, 1, 1, 1], [0, 1, 0, 1, 2], (row indices, column indices)


Stanford Open Office Hours: Dave Evans and Bill Burnett

出门常带三分早

KingPlayer

TED 16岁会20门语言
摩登家庭/Gossip Girl的语料
http://www.rosettastone.com/?prid=sharedtalk_com
听力材料推荐使用ESLPOD，ESLPOD语速适中
阅读材料推荐简单易懂，词汇量要求低的原版书，如果是畅销书更好，比如Charlotte's web,The Houseon Mango Street, The Seven Habits of Highly Efficient People
ESL资源下载链接: 百度云 请输入提取密码 密码: ftjy
Desperate Housewives剧本及笔记: 百度云 请输入提取密码 密码: 5wbk
美剧以及电影剧本下载：The Internet Movie Script Database (IMSDb)
把《跟赖世雄学英语》从音标到中级买回来，为了突破发音，从音标一个一个开始重新学，同时用mp3放美国ESL-pod的教程，听音频，放一句，跟读模仿，一篇文章，跟读几个小时，直到模仿的非常标准为止，再按照艾宾浩斯遗忘曲线的表格复习


Quizlet
Youtube: My English Doctor, Rachel's English

http://code.tradeclassroom.com/

对于大部分交易者而言，看错行情具有一定的持续性，一旦错起来就是一错再错，会老是踏不准市场节奏，反复挨市场的左右耳光。
既然大部分人都忍不住早早补仓，我就坚决不做，也只有越是所有人做不到的事情，我才越有兴趣去做

做惯了投机的人，往往变得头脑睿智肢体懒惰。头脑如此睿智，以至于对周围人的想法一目洞穿。肢体如此懒惰，以至于不愿意为工作付出更多时间、精力和心血

聪明的人总以为可以凌驾于别人之上，也很难发自内心的尊重欣赏谁，但真正的聪明应该是时时刻刻自省，同时小心翼翼的保护每一个身边人的感受

赵炯. Linux内核完全注释 内核版本0.11
http://antriver.com/linux/src/linux-3.15.7.html
OpenGrok/ Source Insight
Boost，Qt，Silicon，tufao，TreeFrog，WTL，STL，libev，Cocos2d-x，Dlib，Ultimate++，Asio，TinyXML，libxml++，CEGUI、FLTK、wxWidgets、Ogre 3D、Cairo、Skia、OpenCV、CxImage、Json++、Json11、CppUnit、OpenSSL、Crypto++、C++React、OpenCL、OpenAL、Vorbis、Memcached、libcurl、SQLite


unit test
https://segmentfault.com/q/1010000002412786/a-1020000002414299
https://github.com/philsquared/Catch

http://www.csindex.com.cn/sseportal/csiportal/hy_syl/syl.jsp 中国指数有限公司

正确的呼吸方式是腹式呼吸，当你吸气时，肚子向外突出；呼气时则相反，肚子回收。加强腹式呼吸，可以促进腹腔运动，改善消化道的血液循环，促进消化道的消化吸收功能，促进肠蠕动，防止便秘，加速毒素的排出

人生就像摆钟一样，在痛苦与无聊之间摇摆：当欲望得不到满足时就痛苦，当欲望得到满足时就无聊

一个人的教养如何体现？不轻易被激怒, 在容易产生矛盾与冲突的环境中，最难掩饰的就是被激怒的阈值, 他们对社会和人生百态的包容度更高

贫穷的本质
当穷人可以多买一点儿食物时，他们并不注重用所有投入换取更多能量，相反，他们会选择买一些口味更好、价钱更高的食物
穷人在选择食品时，主要考虑的并不是价格是否便宜，而不是有无营养价值，而是食物的口味怎么样
穷人的生活中，还有比食物更重要的东西，大量发展中国家的穷人会花很多钱来置办婚礼、嫁妆、洗礼等，这很可能是怕丢面子的结果
穷人的问题并不在食物的数量，而在于食物的质量，特别是微量元素的缺失
穷人常常把钱花在昂贵的治疗上，而不是廉价的预防上
